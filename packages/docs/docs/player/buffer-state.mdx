---
title: "The Player buffer state"
sidebar_label: Buffer state
crumb: Best practices
---

_available from 4.1 // FIXME_

Just like regular video players, it is possible that the content being displayed in the Player is not yet fully loaded.  
In this case, the best practice is to briefly pause the video, let the content load and then resume playback.

Remotion has a native buffer state, which can be used to pause the video when the buffer is empty.

## Mechanic

### Activating the buffer state

A component can tell the player to switch into a buffer state by first using the `useBufferState()` hook and then calling `buffer.delayPlayback()`:

```tsx twoslash title="MyComp.tsx"
import React from "react";
import { useBufferState } from "remotion";

const MyComp: React.FC = () => {
  const buffer = useBufferState();

  React.useEffect(() => {
    const delayHandle = buffer.delayPlayback();

    setTimeout(() => {
      delayHandle.unblock();
    }, 5000);

    return () => {
      delayHandle.unblock();
    };
  }, []);

  return <></>;
};
```

To clear the handle, call `.unblock()` on the return value of `delayPlayback()`.

When activating the buffer state, pay attention to the following:

<details>
<summary>Clear the handle when the component unmounts</summary>

Use the cleanup function of <code>useEffect()</code> to clear the handle when your component is unmounted. The user might seek to a different portion of the video which is immediately available.

```tsx twoslash title="❌ Causes problems with React strict mode"
import React, { useState } from "react";
import { useBufferState } from "remotion";

const MyComp: React.FC = () => {
  const buffer = useBufferState();
  const [delayHandle] = useState(() => buffer.delayPlayback()); // 💥

  React.useEffect(() => {
    setTimeout(() => {
      delayHandle.unblock();
    }, 5000);
  }, []);

  return <></>;
};
```

</details>
<details>
<summary>Don't use <code>delayPlayback()</code> inside a <code>useState()</code></summary>

While the following implementation works in production, it fails in React Strict mode, because the `useState()` hook is called twice, which causes the first invocation of the buffer to never be cleared.

```tsx twoslash title="❌ Doesn't clear the buffer handle when seeking to a different portion of a video"
import React, { useState } from "react";
import { useBufferState } from "remotion";

const MyComp: React.FC = () => {
  const buffer = useBufferState();
  const [delayHandle] = useState(() => buffer.delayPlayback()); // 💥

  React.useEffect(() => {
    setTimeout(() => {
      delayHandle.unblock();
    }, 5000);

    return () => {
      delayHandle.unblock();
    };
  }, []);

  return <></>;
};
```

</details>
<details>
<summary>It doesn't replace <code>delayRender()</code></summary>
<a href="/docs/delay-render">delayRender()</a> is a different API which controls when a screenshot is taken during rendering.
</details>

### Components with built-in buffering

You can enable buffering on the following components:

- [`<Audio>`](/docs/audio)
- [`<Video>`](/docs/video)
- [`<OffthreadVideo>`](/docs/offthreadvideo)
- [`<Img>`](/docs/img)

// FIXME: How?

### Listening to buffer events

If the `<Player />` is entering a buffer state, it will emit the `waiting` event.  
Once it resumes, it emits the `resume` event.

```tsx twoslash title="Listening to waiting and resume events"
// @allowUmdGlobalAccess
// @filename: ./remotion/MyVideo.tsx
export const MyVideo = () => <></>;

// @filename: index.tsx
// ---cut---
import { Player, PlayerRef } from "@remotion/player";
import { useEffect, useRef, useState } from "react";
import { MyVideo } from "./remotion/MyVideo";

export const App: React.FC = () => {
  const playerRef = useRef<PlayerRef>(null);
  const [buffering, setBuffering] = useState(false);

  useEffect(() => {
    const { current } = playerRef;
    if (!current) {
      return;
    }

    const onBuffering = () => {
      setBuffering(true);
    };
    const onResume = () => {
      setBuffering(false);
    };

    current.addEventListener("waiting", onBuffering);
    current.addEventListener("resume", onResume);
    return () => {
      current.removeEventListener("waiting", onBuffering);
      current.removeEventListener("resume", onResume);
    };
  }, [setBuffering]);

  return (
    <Player
      ref={playerRef}
      component={MyVideo}
      durationInFrames={120}
      compositionWidth={1920}
      compositionHeight={1080}
      fps={30}
    />
  );
};
```

### State management

Whether a player is buffering does not internally change the `playing` / `paused` state.  
Therefore, a player can be in four playback states:

<Step>1</Step> <code>playing && !buffering</code> <br />
<Step>2</Step> <code>playing && buffering</code> <br />
<Step>3</Step> <code>paused && !buffering</code> <br />
<Step>4</Step> <code>paused && buffering</code> <br />
<br />

Only in state <InlineStep>1</InlineStep> the time moves forward.

By default, Remotion will display the following UI based on the state of the player:

<Step>1</Step> Pause button <br />
<Step>2</Step> Pause button, then after 500ms (TODO), show a spinner instead <br />
<Step>3</Step>
<Step>4</Step> Play button <br />
<br />

You may add additional UI to this, for example by overlaying the player with a spinner when the player is buffering.
