---
image: /generated/articles-docs-player-custom-controls.png
id: custom-controls
sidebar_label: 'Custom controls'
title: 'Custom controls for the Player'
crumb: '@remotion/player'
---

You may want to implement custom controls for the [`<Player>`](/docs/player/player) component.

There are two approaches:

- Enable the [`controls`](/docs/player/player#controls) prop and granunarly override some or all of the controls inside the Player.
- Disable the [`controls`](/docs/player/player#controls) prop and implement your own controls anywhere on the page.

## Custom inline controls

Use this approach if you:

- Like the default controls but want to customize some of them
- Want the controls to overlay the Player.

Ensure the [`controls`](/docs/player/player#controls) prop is set in the [`<Player/>`](/docs/player/player).  
Use the following APIs to customize the individual controls:

- [`renderPlayPauseButton()`](/docs/player/player#renderplaypausebutton)
- [`renderFullscreenButton()`](/docs/player/player#renderfullscreenbutton)
- [`renderMuteButton()`](/docs/player/player#rendermutebutton)
- [`renderVolumeSlider()`](/docs/player/player#rendervolumeslider)

## Controls outside the Player

Use this approach if you:

- Want to implement custom controls anywhere on the page
- Want full controls over the look and behavior of the controls

Ensure the [`controls`](/docs/player/player#controls) prop is not set in the [`<Player/>`](/docs/player/player).  
Obtain a [`ref`](https://react.dev/learn/referencing-values-with-refs) of type `PlayerRef` of the [`<Player/>`](/docs/player/player) and use the following starting points to implement your own controls:

### Play / Pause button

```tsx twoslash title="PlayPauseButton.tsx"
import type {PlayerRef} from '@remotion/player';
import React, {SVGProps, useCallback, useEffect} from 'react';

export const PlayPauseButton: React.FC<{
  playerRef: React.RefObject<PlayerRef>;
}> = ({playerRef}) => {
  const [playing, setPlaying] = React.useState(
    () => playerRef.current?.isPlaying() ?? false,
  );

  useEffect(() => {
    const {current} = playerRef;
    if (!current) {
      return;
    }

    const onPlay = () => {
      setPlaying(true);
    };

    const onPause = () => {
      setPlaying(false);
    };

    current.addEventListener('play', onPlay);
    current.addEventListener('pause', onPause);

    return () => {
      current.removeEventListener('play', onPlay);
      current.removeEventListener('pause', onPause);
    };
  }, [playerRef]);

  const onToggle = useCallback(() => {
    playerRef.current?.toggle();
  }, [playerRef]);

  return (
    <button onClick={onToggle} type="button">
      {playing ? 'Pause' : 'Play'}
    </button>
  );
};
```

:::note
The [buffering indicator](/docs/player/buffer-state) is not implemented in this snippet.
:::

### Time display

```tsx twoslash title="TimeDisplay.tsx"
import type {PlayerRef} from '@remotion/player';
import React, {useEffect} from 'react';

export const formatTime = (frame: number, fps: number): string => {
  const hours = Math.floor(frame / fps / 3600);

  const remainingMinutes = frame - hours * fps * 3600;
  const minutes = Math.floor(remainingMinutes / 60 / fps);

  const remainingSec = frame - hours * fps * 3600 - minutes * fps * 60;
  const seconds = Math.floor(remainingSec / fps);

  const frameAfterSec = Math.round(frame % fps);

  const hoursStr = String(hours);
  const minutesStr = String(minutes).padStart(2, '0');
  const secondsStr = String(seconds).padStart(2, '0');
  const frameStr = String(frameAfterSec).padStart(2, '0');

  if (hours > 0) {
    return `${hoursStr}:${minutesStr}:${secondsStr}.${frameStr}`;
  }

  return `${minutesStr}:${secondsStr}.${frameStr}`;
};

const TimeDisplay: React.FC<{
  durationInFrames: number;
  fps: number;
  playerRef: React.RefObject<PlayerRef>;
}> = ({durationInFrames, fps, playerRef}) => {
  const [time, setTime] = React.useState(0);

  useEffect(() => {
    const {current} = playerRef;
    if (!current) {
      return;
    }

    const onTimeUpdate = () => {
      setTime(current.getCurrentFrame());
    };

    current.addEventListener('frameupdate', onTimeUpdate);

    return () => {
      current.removeEventListener('frameupdate', onTimeUpdate);
    };
  }, [playerRef]);

  return (
    <div
      style={{
        fontFamily: 'monospace',
      }}
    >
      <span>
        {formatTime(time, fps)}/{formatTime(durationInFrames, fps)}
      </span>
    </div>
  );
};
```

:::note
The [conventional time formatting for video editors](https://github.com/remotion-dev/remotion/issues/694#issuecomment-968318664) is `hh:mm:ss.ff` where `hh` is hours, `mm` is minutes, `ss` is seconds and `ff` is frames past the second.  
:::

### Fullscreen button

Pay attention to two nuances when implementing the Fullscreen button:

- Not all browsers support Fullscreen, feature detection should be performed.
- If using server-side rendering, feature detection should be performed after the component has been mounted on the client to avoid a React hydration mismatch.

```tsx twoslash title="FullscreenButton.tsx"
import type {PlayerRef} from '@remotion/player';
import React, {useCallback, useEffect, useState} from 'react';

export const PlayerFullscreen: React.FC<{
  playerRef: React.RefObject<PlayerRef>;
}> = ({playerRef}) => {
  const [supportsFullscreen, setSupportsFullscreen] = useState(false);
  const [isFullscreen, setIsFullscreen] = useState(false);

  useEffect(() => {
    const {current} = playerRef;

    if (!current) {
      return;
    }

    const onFullscreenChange = () => {
      setIsFullscreen(document.fullscreenElement !== null);
    };

    current.addEventListener('fullscreenchange', onFullscreenChange);

    return () => {
      current.removeEventListener('fullscreenchange', onFullscreenChange);
    };
  }, [playerRef]);

  useEffect(() => {
    // Must be handled client-side to avoid SSR hydration mismatch
    setSupportsFullscreen(
      (typeof document !== 'undefined' &&
        (document.fullscreenEnabled ||
          // @ts-expect-error Types not defined
          document.webkitFullscreenEnabled)) ??
        false,
    );
  }, []);

  const onClick = useCallback(() => {
    const {current} = playerRef;
    if (!current) {
      return;
    }

    if (isFullscreen) {
      current.exitFullscreen();
    } else {
      current.requestFullscreen();
    }
  }, [isFullscreen, playerRef]);

  if (!supportsFullscreen) {
    return null;
  }

  return (
    <button type="button" onClick={onClick}>
      {isFullscreen ? 'Exit Fullscreen' : 'Enter Fullscreen'}
    </button>
  );
};
```

:::note
The `Exit Fullscreen` label is hypothetical since if it is rendered outside of the Player, it would not be visible while in Fullscreen.
:::
