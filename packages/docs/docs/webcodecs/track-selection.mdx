---
image: /generated/articles-docs-webcodecs-track-selection.png
id: track-transformation
title: Track Transformation
slug: /webcodecs/track-transformation
crumb: '@remotion/webcodecs'
---

When transforming media, there are multiple thing that can be done for each audio or video track:

- Copying the track without re-encoding
- Re-encoding the track into a different codec
- Removing the track

[`@remotion/webcodecs`](/docs/webcodecs) allows you to decide for each track what to do with it.

## Using the defaults

The minimum amount of configuration is to only specify a [`src`](/docs/webcodecs/convert-media#src) and an output [`container`](/docs/webcodecs/convert-media#container).

```tsx twoslash title="Using the default codecs"
// @module: es2022
// @target: es2017
import {convertMedia} from '@remotion/webcodecs';

await convertMedia({
  src: 'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4',
  container: 'webm',
});
```

## Choosing codecs

You can use the [`videoCodec`](/docs/webcodecs/convert-media#videocodec) and [`audioCodec`](/docs/webcodecs/convert-media#audiocodec) options to transform all tracks to the codecs you specify.

```tsx twoslash title="Choosing video and audio codecs"
// @module: es2022
// @target: es2017
import {convertMedia} from '@remotion/webcodecs';

await convertMedia({
  src: 'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4',
  container: 'webm',
  videoCodec: 'vp8',
  audioCodec: 'opus',
});
```

## Handle each track individually

With the [`onVideoTrack`](/docs/webcodecs/convert-media#onvideotrack) and [`onAudioTrack`](/docs/webcodecs/convert-media#onaudiotrack) callbacks, you can decide for each track what to do with it.

```tsx twoslash title="Using the onVideoTrack() API"
// @module: es2022
// @target: es2017
import {convertMedia} from '@remotion/webcodecs';

await convertMedia({
  src: 'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4',
  container: 'webm',
  audioCodec: 'opus',
  onVideoTrack: ({track}) => {
    if (track.codecWithoutConfig === 'vp8') {
      return {type: 'copy'};
    }

    return {type: 'reencode', videoCodec: 'vp8'};
  },
});
```

[`onVideoTrack`](/docs/webcodecs/convert-media#onvideotrack) and [`onAudioTrack`](/docs/webcodecs/convert-media#onaudiotrack) have a higher priority than [`videoCodec`](/docs/webcodecs/convert-media#videocodec) and [`audioCodec`](/docs/webcodecs/convert-media#audiocodec).

The options for video codecs are:

- `{"type": "copy"}` - Copy the track without re-encoding
- `{"type": "reencode", "videoCodec": ConvertMediaVideoCodec}` - Re-encode the track into the specified codec
- `{"type": "drop"}` - Remove the track from the output
- `{"type": "fail"}` - Fail and stop the conversion process

The options for audio codecs are:

- `{"type": "copy"}` - Copy the track without re-encoding
- `{"type": "reencode", "audioCodec": ConvertMediaAudioCodec; bitrate: number}` - Re-encode the track into the specified codec. The suggested bitrate to use is `128000`.
- `{"type": "drop"}` - Remove the track from the output
- `{"type": "fail"}` - Fail and stop the conversion process

The enums `ConvertMediaVideoCodec` and `ConvertMediaAudioCodec` can be imported from `@remotion/webcodecs`.

## Checking if a track can be copied

To check if it is possible to return `{"type": "copy"}`, you can use the [`canCopyVideoTrack()`](/docs/webcodecs/convert-media#cancopyvideotrack) and [`canCopyAudioTrack()`](/docs/webcodecs/convert-media#cancopyaudiotrack) APIs.

```tsx twoslash title="Using the canCopyVideoTrack() API"
// @module: es2022
// @target: es2017
import {convertMedia, canCopyVideoTrack} from '@remotion/webcodecs';

await convertMedia({
  src: 'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4',
  container: 'webm',
  audioCodec: 'opus',
  onVideoTrack: ({track, container}) => {
    const canCopy = canCopyVideoTrack({
      inputCodec: track.codecWithoutConfig,
      container,
    });

    if (canCopy) {
      return {type: 'copy'};
    }

    return {type: 'reencode', videoCodec: 'vp8'};
  },
});
```

## Checking if a track can be re-encoded

To check if it is possible to return `{"type": "reencode"}`, you can use the [`canReencodeVideoTrack()`](/docs/webcodecs/convert-media#canreencodevideotrack) and [`canReencodeAudioTrack()`](/docs/webcodecs/convert-media#canreencodeaudiotrack) APIs.

```tsx twoslash title="Using the canReencodeVideoTrack() API"
// @module: es2022
// @target: es2017
import {convertMedia, canReencodeVideoTrack} from '@remotion/webcodecs';

await convertMedia({
  src: 'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4',
  container: 'webm',
  audioCodec: 'opus',
  onVideoTrack: async ({track, container}) => {
    const canReencode = await canReencodeVideoTrack({
      videoCodec: 'vp8',
      track,
    });

    if (canReencode) {
      return {type: 'reencode', videoCodec: 'vp8'};
    }

    return {type: 'drop'};
  },
});
```

## Asynchronously determining config

The [`onAudioTrack`](/docs/webcodecs/convert-media#onaudiotrack) and [`onVideoTrack`](/docs/webcodecs/convert-media#onvideotrack) callbacks can be asynchronous.  
While the operations are unresolved, reading of the input fill is paused.

## Falling back to default

## Debugging

Pass [`logLevel: "verbose"`](/docs/webcodecs/convert-media#loglevel) to [`convertMedia()`](/docs/convert-media) to see debug information in the console, including how the defaults have decided which operations to take.

## Reference implementation

Visit the [source code](https://github.com/remotion-dev/remotion/tree/main/packages/convert) for [convert.remotion.dev](https://convert.remotion.dev) to see a reference implementation for an online video converter that displays a user interface for all possible options.
