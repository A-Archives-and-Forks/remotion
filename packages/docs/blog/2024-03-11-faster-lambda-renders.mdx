---
slug: faster-lambda-renders
title: Lambda renders are now faster
author: Jonny Burger
author_title: Chief Hacker @ Remotion
author_url: https://github.com/JonnyBurger
author_image_url: https://avatars2.githubusercontent.com/u/1629785?s=460&u=12eb94da6070d00fc924761ce06e3a428d01b7e9&v=4
image: /img/todo.png
---

import { AacFile } from "../components/Aac/AacFile";
import { AacPadding } from "../components/Aac/AacPadding";
import { AacConcatenationProblem } from "../components/Aac/AacConcatenationProblem";
import { AacKeyframes } from "../components/Aac/AacKeyframes";

With Remotion v4.0.123, [Remotion Lambda](/lambda) renders now finish significantly faster!

- 1 minute video: 15 seconds faster
- 10 minute video: 2 minutes faster
- 40 minute Video: 8 minutes faster

TODO: Quantify the speedup

Thanks to an innovative audio concatenation strategy that we implemented with help from [Max Schnur](https://github.com/maxpower15) from [Wistia](https://wistia.com/), we can skip an audio re-encoding step at the end.

## Audio is the slow part

Remotion Lambda renders chunks of a video in parallel and concatenates them at the end.  
The slow part is actually not the video, but the audio rendering!

While other codecs are possible, a `.mp4` file usually contains AAC audio.

Concatenating the AAC chunks is usually not possible without creating some artifacts.

## How AAC works

An AAC audio stream contains many packets. Each packet contains exactly 1024 samples.

<AacFile />

<br />
<br />

The duration of the audio must be divisible by 1024 samples. If your audio does not fit, you must pad the last packet with silence!

<AacPadding />
<br />
<br />

When concatenating AAC audio, this padding of silence is noticeable and can be heard as a popping noise:

<AacConcatenationProblem />
<br />
<br />

To avoid this artifact, the whole audio needs to be re-encoded at the end. The longer the audio, the worse the problem!

## A packet has dependencies

Making the problem harder, an AAC packet is not self-contained. The waveform also depends on the previous and next packets!

<AacKeyframes />
<br />
<br />

This means we cannot create packet-sized audio slices and concatenate them because we'd have to include their padding as well.

## Who can solve this problem?

Online resources such as Stack Overflow were quickly exhausted.

I went to the [RTC.on](https://rtcon.live/) multimedia conference and talked about this problem in my talk.

A few listeners came up to me afterwards and gave me a few ideas. I did a session with [Michał Śledź](https://github.com/mickel8) from [Software Mansion](https://swmansion.com/), all of which helped me even understand the problem we are facing in the first place.

No immediate solution was found, but the problem was put aside when we realized that the `libfdk-aac` encoder is twice as fast as FFmpeg's native encoder, softened the problem for the moment.

## An innovative way to contatenate AAC

Out of the blue, Max Schnur from Wistia appeared with a solution and posted it on the [Remotion Discord](https://remotion.dev/discord)!

<AacConcatenationSolution />
<br />
<br />

Tricky:

- It's not always 2 extra frames of padding, sometimes 3, sometimes 1
- Some frames are rendered twice, however no screenshot is taken, only audio
- `inpoint` and `outpoint` FFmpeg filters need to be nano-second precise
- All audio needs to be resampled to 48000
- Remotion supports multiple audio layers, with offsets, volume curve, pitch shifting, and speed correction
- Rendering only a portion of a video will shift the start timestamp, which changes the math
- The video frame rate of `1 / 30` and the audio sample rate of `1 / 48000` does not align perfectly. We capture too much padding which needs to be trimmed off for each chunk.
- FFmpeg `atempo` filter is not perfect
- AAC has a 512 frame padding in the front.

## Benchmarks

import { AacConcatenationSolution } from "../components/Aac/AacConcatenationSolution";
